#include "interpreter.h"
#include "module.h"
#include "utils.h"
#include <stdbool.h>
#include <stdio.h>

// 控制块（包含函数）被调用前，将【待调用的控制块（包含函数）关联的栈帧】压入到调用栈顶，成为当前栈帧，
// 同时保存该栈帧被压入调用栈顶前的运行时状态，例如 sp fp ra 等
void push_block(Module *m, Block *block, int sp) {
    /* 1. 压入调用栈顶 */

    // 因新的栈帧要压入调用栈顶成为当前栈帧，所以调用栈指针（保存处在调用栈顶的栈帧索引）要加 1
    m->csp += 1;

    /* 2. 关联控制块 */

    // 将 参数 block 设置为 当前栈帧关联的控制块
    m->callstack[m->csp].block = block;

    /* 3. 保存 sp */

    // 将该栈帧被压入操作数栈顶前的【操作数栈顶指针】的值保存到 frame->sp 中，
    // 以便后续当前栈帧关联的控制块执行完成，当前栈帧弹出后，恢复压栈前的【操作数栈顶指针】
    m->callstack[m->csp].sp = sp;

    /* 4. 保存 fp */

    // 将该栈帧被压入操作数栈顶前的【当前栈帧的操作数栈底指针】的值保存到 frame>fp 中，
    // 以便后续该栈帧关联的控制块执行完成，该栈帧弹出后，恢复压栈前的【当前栈帧的操作数栈底指针】
    m->callstack[m->csp].fp = m->fp;

    /* 5. 保存 ra */

    // 将该栈帧被压入操作数栈顶前的【下一条即将执行的指令的地址】的值保存到 frame>ra 中，
    // 以便后续该栈帧关联的函数执行完后，返回到调用该函数的地方继续执行后面的指令
    m->callstack[m->csp].ra = m->pc;
}

// 当前控制块（包含函数）执行结束后，将【已执行结束的当前控制块（包含函数）关联的当前栈帧】从调用栈顶中弹出，
// 同时恢复该栈帧被压入调用栈顶前的运行时状态，例如 sp fp ra 等
Block *pop_block(Module *m) {
    /* 1. 弹出调用栈顶 */

    // 从调用栈顶中弹出当前栈帧，同时调用栈指针减 1
    Frame *frame = &m->callstack[m->csp--];

    /* 2. 校验控制块的返回值类型 */

    // 获取控制帧对应控制块（包含函数）的签名（即控制块的返回值的数量和类型）
    Type *t = frame->block->type;
    // 背景知识：目前多返回值提案还没有进入 Wasm 标准，根据当前版本的 Wasm 标准，控制块不能有参数，且最多只能有一个返回值
    // 如果控制块的返回值数量为 1，也就是有一个返回值时，需要对返回值类型进行校验
    if (t->result_count == 1) {
        // 获取当前栈帧的操作数栈顶值，也就是控制块（包含函数）的返回值，
        // 判断其类型和【控制块签名中的返回值类型】是否一致，如果不一致则报错
        if (m->stack[m->sp].value_type != t->results[0]) {
            sprintf(exception, "call type mismatch");
            return NULL;
        }
    }

    /* 3. 恢复 sp */

    // 因为该栈帧弹出，所以需要恢复该栈帧被压入调用栈前的【操作数栈顶指针】
    // 注：frame->sp 保存的是该栈帧被压入调用栈前的【操作数栈顶指针】的值
    if (t->result_count == 1) {
        // 背景知识：目前多返回值提案还没有进入 Wasm 标准，根据当前版本的 Wasm 标准，控制块不能有参数，且最多只能有一个返回值
        // 如果控制块有一个返回值，则这个返回值需要压入到恢复后的操作数栈顶，即恢复后的操作数栈长度需要加 1
        // 所以恢复的【操作数栈顶指针值】 是 该栈帧被压入调用栈前的【操作数栈顶指针】的值再加 1
        if (frame->sp < m->sp) {
            m->stack[frame->sp + 1] = m->stack[m->sp];
            m->sp = frame->sp + 1;
        }
    } else {
        // 如果控制块没有返回值，则直接恢复该栈帧被压入调用栈前的【操作数栈顶指针】即可
        if (frame->sp < m->sp) {
            m->sp = frame->sp;
        }
    }

    /* 4. 恢复 fp */

    // 因为该栈帧弹出，所以需要恢复该栈帧被压入调用栈前的【当前栈帧的操作数栈底指针】
    // 注：frame->fp 保存的是该栈帧被压入调用栈前的【当前栈帧的操作数栈底指针】的值
    m->fp = frame->fp;

    /* 5. 恢复 ra */

    // 当控制块类型为函数时，在函数执行完成该栈帧弹出时，需要返回到该函数调用指令的下一条指令继续执行
    if (frame->block->block_type == 0x00) {
        // 将函数返回地址赋给程序计数器 pc（记录下一条即将执行的指令的地址）
        m->pc = frame->ra;
    }

    return frame->block;
}

// 为调用索引为 fidx 的函数作准备，主要准备如下：
// 将函数参数和局部变量压入操作数栈，并将当前控制控制帧保存到控制栈中
// 且将函数的起始指令地址设置为 pc（program counter 程序计数器，用于记录下一条待执行指令的地址）
void setup_call(Module *m, uint32_t fidx) {
}

// 虚拟机执行字节码中的指令流
bool interpret(Module *m) {
    // 正常情况不会执行到这里
    return false;
}
